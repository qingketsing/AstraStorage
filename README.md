# AstraStorage

AstraStorage is a distributed file storage system. The reason why I create this system is that the download speed of commercial cloud storage service is too slow,so I create this system for person who has many servers and want to make them as a storage system.

This Storage system used redis, rabbitMQ And postgresql.The postgresql is used to store metadata, and message queue is used to communicate with leader node. Each node has a sql and the redis and rabbitMQ is only listen to leader node. 

For Leader node, I used Raft to election leader node. And the leader node will handle all the write requests and broadcast the write requests to other nodes.

This system povided the service of upload, download, delete, query and update. In the future, I'm ganna to add the Download offline service and some interesting features.

hmm, honestly speaking, I don't know if you really need this system. If you have some advice please contact me LOL.

Anyway, Love and Peace~

## File Tree

```
.
├── bin
│   ├── node        # For Linux
│   └── node.exe    # For Windows
├── cmd             # Command line tools
│   ├── client      # As it says XD
│   └── node        # As it says 2 XD
├── docker          # Docker setup files
├── internal        # Internal Part
│   ├── core        # Core Part
│   │   ├── cluster               # Cluster Part
│   │   │   ├── cluster.go        # Cluster Manager
│   │   │   ├── cluster_test.go   # Test for cluster
│   │   │   └── node.go           # Node Manager
│   │   └── repository            # Repository Part
│   │       └── repository.go     # Repository Manager
│   ├── middleware                # Middleware Part 
│   │   ├── RabbitMQ.go           
│   │   ├── rabbitmq_manager.go   # RabbitMQ Manager
│   │   ├── Redis.go              
│   │   └── redis_manager.go      # Redis Manager
│   └── storage                   # Storage Part
│       ├── storage.go
│       ├── delete                # Delete Service
│       │   └── service.go
│       ├── download              # Download Service
│       │   ├── servive.go
│       │   └── tcp_server.go
│       ├── query                 # Query Service
│       │   └── service.go
│       ├── update                # Update Service
│       │   └── service.go
│       └── upload                # Upload Service
│           ├── service.go
│           └── tcp_server.go
├── scripts                       # Scripts Part
│   ├── init_database.sql        # Initialize the Database
│   ├── run_integration_test.ps1 # Run Integration Test
│   ├── start_docker_cluster.ps1 # Start Docker Cluster
│   ├── start_nodes.ps1          # Start cmd For Windows
│   ├── stop_docker_cluster.ps1  # Stop Docker Cluster
│   ├── stop_nodes.ps1           # Stop cmd For Windows
│   ├── test_cluster.ps1         # Test Cluster
│   └── view_docker_logs.ps1     # Check Docker Logs
├── tests                        # Tests Part
│   ├── file_delete_test.go      # As it says XD
│   ├── file_query_test.go 
│   ├── file_update_test.go
│   ├── file_upload_download_test.go
│   ├── file_upload_test.go
│   ├── metadata_sync_test.go
│   ├── QUICKSTART.md            # Generated by AI XD
│   └── README.md                # Generated by AI 2 
├── .dockerignore
├── docker-compose.yml           # Compose File
├── Dockerfile                   # Dockerfile
├── go.mod
├── go.sum
└── LICENSE                      # This is the License
```

## Service Description

Before we introduce the service, we should know that the file transport is based on TCP, and it was split into chunks, each chunk is 1MB.

### Upload Service

For Upload, the client will send a request to leader node, and the leader node will handle the request and broadcast the request to other nodes. The leader node will choose 3 nodes(include itself) to store the file and its metadata.  Then the leader will broadcast the metadata to other nodes who don't store the file. By this way, the file will be stored in 3 nodes and the metadata will be stored in all nodes.

### Download Service

For Download, the client will send a request to leader node, and the leader node will find the fastest node(to download) and the leader node will send the request to the fastest node. The fastest node will send the file to the client.

### Delete Service

For Delete, the leader node will delete the file and its metadata from all nodes. The nodes who has the file will also delete the file. This was done by broadcast the delete request to all nodes. And the nodes who has the file is searched by metadata.

### Query Service

This part We used redis. If you send a query request, the leader node will first check the redis. If it has this file's metadata, it will return the metadata. Otherwise, it will broadcast the query request to all nodes. Then after get the metadata, Leader node will put the metadata into redis and return the metadata to client.

### Update Service

For Update, the leader node will update the file and its metadata from all nodes. The leader node will broadcast the update request to all nodes. And the nodes who has the file is searched by metadata too.

## Technology Stack

- Go 1.22.2
- Docker 25.0.1
- PostgreSQL 16.2
- Redis 7.2.6
- RabbitMQ 3.12.1

Go is the main part of this system.

Docker is used to run the system and initialize the database. It is also the entry of the system.

PostgreSQL is used to store metadata.Each node has a PostgreSQL node.

Redis is used to store metadata temporarily.

RabbitMQ is used to communicate with leader node.

RabbitMQ and Redis is only used by leader node.These two docker image will check which node is leader and only provide service to leader node.